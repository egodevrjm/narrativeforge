{"ast":null,"code":"var _jsxFileName = \"/Users/ryanmorrison/Code/narrativeforge/src/components/SetupMode/QuickSetup.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport { RefreshCw } from 'lucide-react';\n\n/**\n * QuickSetup - A streamlined setup component allowing users to input\n * all character and scenario details in a single text area\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst QuickSetup = ({\n  onSave,\n  geminiService,\n  onReset\n}) => {\n  _s();\n  const [setupText, setSetupText] = useState('');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [processingError, setProcessingError] = useState(null);\n\n  // Process the text and try to extract character and scenario information\n  const processSetupText = async () => {\n    try {\n      setIsProcessing(true);\n      setProcessingError(null);\n      if (!setupText.trim()) {\n        setProcessingError('Please enter some text before processing');\n        return;\n      }\n\n      // Option 1: Use Gemini to parse the input if service is available\n      if (geminiService) {\n        const prompt = `Extract character and scenario details from the following roleplay setup text. \n        \n        TEXT:\n        ${setupText}\n        \n        INSTRUCTIONS:\n        Return a valid JSON object containing two nested objects: 'character' and 'scenario'. Follow this exact structure:\n        \n        {\n          \"character\": {\n            \"name\": \"Character's name (extract or use 'Unnamed Character' if not found)\",\n            \"age\": \"Character's age (extract or use '25' if not found)\",\n            \"physicalDescription\": \"Character's physical description (extract or use empty string if not found)\",\n            \"background\": \"Character's background (extract or use empty string if not found)\",\n            \"personality\": \"Character's personality (extract or use empty string if not found)\",\n            \"relationships\": [\n              {\n                \"name\": \"Related character's name\",\n                \"relationshipType\": \"Type of relationship\",\n                \"description\": \"Description of the relationship\"\n              }\n            ],\n            \"additionalNotes\": \"Any additional character details\"\n          },\n          \"scenario\": {\n            \"title\": \"Scenario title (extract or use 'Untitled Scenario' if not found)\",\n            \"setting\": {\n              \"location\": \"Scenario location (extract or use empty string if not found)\",\n              \"time\": \"Time period (extract or use 'Present day' if not found)\",\n              \"atmosphere\": \"Atmosphere description (extract or use empty string if not found)\"\n            },\n            \"initialSituation\": \"Initial situation (extract or use a summary of the input if not explicit)\",\n            \"otherCharacters\": [\n              {\n                \"name\": \"NPC name\",\n                \"role\": \"NPC role\",\n                \"description\": \"NPC description\",\n                \"relationship\": \"Relationship to main character\"\n              }\n            ],\n            \"narrativeGoals\": \"Narrative goals (extract or use empty string if not found)\",\n            \"toneAndThemes\": \"Tone and themes (extract or use empty string if not found)\",\n            \"roleplayInstructions\": \"Any explicit roleplay instructions (extract or use empty string if not found)\"\n          }\n        }\n        \n        Do your best to extract meaningful information even if the text is not structured. If relationships or other characters aren't explicitly mentioned, create reasonable entries based on the context, or leave arrays empty if there's nothing to work with. Only respond with the JSON object and no other text.`;\n        try {\n          const response = await geminiService.generateGeneric(prompt);\n\n          // Try to parse the JSON response\n          try {\n            // Find the JSON in the response using a regex\n            const jsonRegex = /\\{(?:[^{}]|\\{(?:[^{}]|\\{[^{}]*\\})*\\})*\\}/g;\n            const matches = response.match(jsonRegex);\n            if (matches && matches.length > 0) {\n              // Use the largest match (most complete JSON)\n              const jsonString = matches.reduce((a, b) => a.length > b.length ? a : b);\n              const parsedData = JSON.parse(jsonString);\n\n              // Validate the data structure\n              if (parsedData.character && parsedData.scenario) {\n                // Success! Pass the data to parent\n                onSave(parsedData.character, parsedData.scenario);\n                return;\n              } else {\n                throw new Error('Parsed JSON is missing required character or scenario data');\n              }\n            } else {\n              throw new Error('Failed to extract JSON from AI response');\n            }\n          } catch (jsonError) {\n            console.error('JSON parsing error:', jsonError);\n            setProcessingError(`Failed to extract character and scenario data: ${jsonError.message}`);\n          }\n        } catch (aiError) {\n          console.error('AI processing error:', aiError);\n          setProcessingError(`AI processing failed: ${aiError.message}`);\n        }\n      } else {\n        // Option 2: Manual basic extraction (fallback if no AI service)\n        performBasicExtraction();\n      }\n    } catch (error) {\n      console.error('Setup processing error:', error);\n      setProcessingError(`An error occurred: ${error.message}`);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Basic extraction logic without AI (very limited)\n  const performBasicExtraction = () => {\n    const lines = setupText.split('\\n');\n    const character = {\n      name: extractValue(lines, 'name:') || 'Unnamed Character',\n      age: extractValue(lines, 'age:') || '25',\n      physicalDescription: extractValue(lines, 'physical description:') || '',\n      background: extractValue(lines, 'background:') || '',\n      personality: extractValue(lines, 'personality:') || '',\n      relationships: [],\n      additionalNotes: ''\n    };\n    const scenario = {\n      title: extractValue(lines, 'title:') || 'Untitled Scenario',\n      setting: {\n        location: extractValue(lines, 'location:') || '',\n        time: extractValue(lines, 'time:') || 'Present day',\n        atmosphere: extractValue(lines, 'atmosphere:') || ''\n      },\n      initialSituation: extractValue(lines, 'initial situation:') || setupText.substring(0, 500),\n      otherCharacters: [],\n      narrativeGoals: extractValue(lines, 'goals:') || '',\n      toneAndThemes: extractValue(lines, 'tone:') || '',\n      roleplayInstructions: ''\n    };\n\n    // Try to extract relationships\n    const relationshipMatch = setupText.match(/relationship[^:]*:([^\\.]+)/i);\n    if (relationshipMatch && relationshipMatch[1]) {\n      character.relationships.push({\n        name: 'Extracted Character',\n        relationshipType: 'Relationship',\n        description: relationshipMatch[1].trim()\n      });\n    }\n\n    // Try to extract other characters\n    const characterMatch = setupText.match(/character[^:]*:([^\\.]+)/i);\n    if (characterMatch && characterMatch[1]) {\n      scenario.otherCharacters.push({\n        name: 'Extracted Character',\n        role: 'Supporting Character',\n        description: characterMatch[1].trim(),\n        relationship: 'Unknown'\n      });\n    }\n    onSave(character, scenario);\n  };\n\n  // Helper to extract values from text lines\n  const extractValue = (lines, key) => {\n    const regex = new RegExp(key, 'i');\n    const line = lines.find(l => regex.test(l));\n    if (line) {\n      const parts = line.split(/:\\s*/);\n      if (parts.length > 1) {\n        return parts.slice(1).join(':').trim();\n      }\n    }\n    return '';\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"quick-setup-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Quick Setup Mode\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 185,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      className: \"setup-description\",\n      children: \"Paste your entire character and scenario setup in the box below. The AI will try to extract all relevant information in one go.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 186,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"form-actions-top\",\n      children: /*#__PURE__*/_jsxDEV(\"button\", {\n        type: \"button\",\n        className: \"reset-btn\",\n        onClick: onReset,\n        children: \"Start Over\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 192,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 191,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"setup-form\",\n      children: [/*#__PURE__*/_jsxDEV(\"textarea\", {\n        className: \"setup-textarea\",\n        value: setupText,\n        onChange: e => setSetupText(e.target.value),\n        rows: 15,\n        placeholder: `Paste or type all your character and scenario details here. Try to include:\n\nCharacter name: \nCharacter age: \nPhysical description: \nBackground: \nPersonality: \nRelationships: \n\nScenario title: \nLocation: \nTime: \nAtmosphere: \nInitial situation: \nOther characters: \nNarrative goals: \nTone and themes: \n\nThe AI will attempt to parse this information, even if it's not perfectly structured.`\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 198,\n        columnNumber: 9\n      }, this), processingError && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"processing-error\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: processingError\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 226,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 225,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"setup-actions\",\n        children: /*#__PURE__*/_jsxDEV(\"button\", {\n          type: \"button\",\n          className: \"process-btn\",\n          onClick: processSetupText,\n          disabled: isProcessing || !setupText.trim(),\n          children: [isProcessing ? 'Processing...' : 'Process and Start Roleplay', isProcessing && /*#__PURE__*/_jsxDEV(RefreshCw, {\n            size: 18,\n            className: \"spinning\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 238,\n            columnNumber: 30\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 231,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 230,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 197,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"quick-setup-help\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        children: \"Tips for best results:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n        children: [/*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Include clear labels like \\\"Character name:\\\" or \\\"Location:\\\" to help the AI identify information.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 246,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"Provide as much detail as you can about both the character and scenario.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 247,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"If you have specific roleplay instructions, label them clearly as \\\"Roleplay instructions:\\\"\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 248,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n          children: \"The AI will make its best guess at extracting information, but you can always edit details in the chat.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 249,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 245,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 243,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 184,\n    columnNumber: 5\n  }, this);\n};\n_s(QuickSetup, \"xNDDX6FDC9+2tCiGRpLv014Rym0=\");\n_c = QuickSetup;\nexport default QuickSetup;\nvar _c;\n$RefreshReg$(_c, \"QuickSetup\");","map":{"version":3,"names":["React","useState","RefreshCw","jsxDEV","_jsxDEV","QuickSetup","onSave","geminiService","onReset","_s","setupText","setSetupText","isProcessing","setIsProcessing","processingError","setProcessingError","processSetupText","trim","prompt","response","generateGeneric","jsonRegex","matches","match","length","jsonString","reduce","a","b","parsedData","JSON","parse","character","scenario","Error","jsonError","console","error","message","aiError","performBasicExtraction","lines","split","name","extractValue","age","physicalDescription","background","personality","relationships","additionalNotes","title","setting","location","time","atmosphere","initialSituation","substring","otherCharacters","narrativeGoals","toneAndThemes","roleplayInstructions","relationshipMatch","push","relationshipType","description","characterMatch","role","relationship","key","regex","RegExp","line","find","l","test","parts","slice","join","className","children","fileName","_jsxFileName","lineNumber","columnNumber","type","onClick","value","onChange","e","target","rows","placeholder","disabled","size","_c","$RefreshReg$"],"sources":["/Users/ryanmorrison/Code/narrativeforge/src/components/SetupMode/QuickSetup.js"],"sourcesContent":["import React, { useState } from 'react';\nimport { RefreshCw } from 'lucide-react';\n\n/**\n * QuickSetup - A streamlined setup component allowing users to input\n * all character and scenario details in a single text area\n */\nconst QuickSetup = ({ onSave, geminiService, onReset }) => {\n  const [setupText, setSetupText] = useState('');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [processingError, setProcessingError] = useState(null);\n\n  // Process the text and try to extract character and scenario information\n  const processSetupText = async () => {\n    try {\n      setIsProcessing(true);\n      setProcessingError(null);\n\n      if (!setupText.trim()) {\n        setProcessingError('Please enter some text before processing');\n        return;\n      }\n\n      // Option 1: Use Gemini to parse the input if service is available\n      if (geminiService) {\n        const prompt = `Extract character and scenario details from the following roleplay setup text. \n        \n        TEXT:\n        ${setupText}\n        \n        INSTRUCTIONS:\n        Return a valid JSON object containing two nested objects: 'character' and 'scenario'. Follow this exact structure:\n        \n        {\n          \"character\": {\n            \"name\": \"Character's name (extract or use 'Unnamed Character' if not found)\",\n            \"age\": \"Character's age (extract or use '25' if not found)\",\n            \"physicalDescription\": \"Character's physical description (extract or use empty string if not found)\",\n            \"background\": \"Character's background (extract or use empty string if not found)\",\n            \"personality\": \"Character's personality (extract or use empty string if not found)\",\n            \"relationships\": [\n              {\n                \"name\": \"Related character's name\",\n                \"relationshipType\": \"Type of relationship\",\n                \"description\": \"Description of the relationship\"\n              }\n            ],\n            \"additionalNotes\": \"Any additional character details\"\n          },\n          \"scenario\": {\n            \"title\": \"Scenario title (extract or use 'Untitled Scenario' if not found)\",\n            \"setting\": {\n              \"location\": \"Scenario location (extract or use empty string if not found)\",\n              \"time\": \"Time period (extract or use 'Present day' if not found)\",\n              \"atmosphere\": \"Atmosphere description (extract or use empty string if not found)\"\n            },\n            \"initialSituation\": \"Initial situation (extract or use a summary of the input if not explicit)\",\n            \"otherCharacters\": [\n              {\n                \"name\": \"NPC name\",\n                \"role\": \"NPC role\",\n                \"description\": \"NPC description\",\n                \"relationship\": \"Relationship to main character\"\n              }\n            ],\n            \"narrativeGoals\": \"Narrative goals (extract or use empty string if not found)\",\n            \"toneAndThemes\": \"Tone and themes (extract or use empty string if not found)\",\n            \"roleplayInstructions\": \"Any explicit roleplay instructions (extract or use empty string if not found)\"\n          }\n        }\n        \n        Do your best to extract meaningful information even if the text is not structured. If relationships or other characters aren't explicitly mentioned, create reasonable entries based on the context, or leave arrays empty if there's nothing to work with. Only respond with the JSON object and no other text.`;\n\n        try {\n          const response = await geminiService.generateGeneric(prompt);\n          \n          // Try to parse the JSON response\n          try {\n            // Find the JSON in the response using a regex\n            const jsonRegex = /\\{(?:[^{}]|\\{(?:[^{}]|\\{[^{}]*\\})*\\})*\\}/g;\n            const matches = response.match(jsonRegex);\n            \n            if (matches && matches.length > 0) {\n              // Use the largest match (most complete JSON)\n              const jsonString = matches.reduce((a, b) => a.length > b.length ? a : b);\n              const parsedData = JSON.parse(jsonString);\n              \n              // Validate the data structure\n              if (parsedData.character && parsedData.scenario) {\n                // Success! Pass the data to parent\n                onSave(parsedData.character, parsedData.scenario);\n                return;\n              } else {\n                throw new Error('Parsed JSON is missing required character or scenario data');\n              }\n            } else {\n              throw new Error('Failed to extract JSON from AI response');\n            }\n          } catch (jsonError) {\n            console.error('JSON parsing error:', jsonError);\n            setProcessingError(`Failed to extract character and scenario data: ${jsonError.message}`);\n          }\n        } catch (aiError) {\n          console.error('AI processing error:', aiError);\n          setProcessingError(`AI processing failed: ${aiError.message}`);\n        }\n      } else {\n        // Option 2: Manual basic extraction (fallback if no AI service)\n        performBasicExtraction();\n      }\n    } catch (error) {\n      console.error('Setup processing error:', error);\n      setProcessingError(`An error occurred: ${error.message}`);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Basic extraction logic without AI (very limited)\n  const performBasicExtraction = () => {\n    const lines = setupText.split('\\n');\n    const character = {\n      name: extractValue(lines, 'name:') || 'Unnamed Character',\n      age: extractValue(lines, 'age:') || '25',\n      physicalDescription: extractValue(lines, 'physical description:') || '',\n      background: extractValue(lines, 'background:') || '',\n      personality: extractValue(lines, 'personality:') || '',\n      relationships: [],\n      additionalNotes: ''\n    };\n\n    const scenario = {\n      title: extractValue(lines, 'title:') || 'Untitled Scenario',\n      setting: {\n        location: extractValue(lines, 'location:') || '',\n        time: extractValue(lines, 'time:') || 'Present day',\n        atmosphere: extractValue(lines, 'atmosphere:') || ''\n      },\n      initialSituation: extractValue(lines, 'initial situation:') || setupText.substring(0, 500),\n      otherCharacters: [],\n      narrativeGoals: extractValue(lines, 'goals:') || '',\n      toneAndThemes: extractValue(lines, 'tone:') || '',\n      roleplayInstructions: ''\n    };\n\n    // Try to extract relationships\n    const relationshipMatch = setupText.match(/relationship[^:]*:([^\\.]+)/i);\n    if (relationshipMatch && relationshipMatch[1]) {\n      character.relationships.push({\n        name: 'Extracted Character',\n        relationshipType: 'Relationship',\n        description: relationshipMatch[1].trim()\n      });\n    }\n\n    // Try to extract other characters\n    const characterMatch = setupText.match(/character[^:]*:([^\\.]+)/i);\n    if (characterMatch && characterMatch[1]) {\n      scenario.otherCharacters.push({\n        name: 'Extracted Character',\n        role: 'Supporting Character',\n        description: characterMatch[1].trim(),\n        relationship: 'Unknown'\n      });\n    }\n\n    onSave(character, scenario);\n  };\n\n  // Helper to extract values from text lines\n  const extractValue = (lines, key) => {\n    const regex = new RegExp(key, 'i');\n    const line = lines.find(l => regex.test(l));\n    if (line) {\n      const parts = line.split(/:\\s*/);\n      if (parts.length > 1) {\n        return parts.slice(1).join(':').trim();\n      }\n    }\n    return '';\n  };\n\n  return (\n    <div className=\"quick-setup-container\">\n      <h2>Quick Setup Mode</h2>\n      <p className=\"setup-description\">\n        Paste your entire character and scenario setup in the box below. \n        The AI will try to extract all relevant information in one go.\n      </p>\n\n      <div className=\"form-actions-top\">\n        <button type=\"button\" className=\"reset-btn\" onClick={onReset}>\n          Start Over\n        </button>\n      </div>\n\n      <div className=\"setup-form\">\n        <textarea\n          className=\"setup-textarea\"\n          value={setupText}\n          onChange={(e) => setSetupText(e.target.value)}\n          rows={15}\n          placeholder={`Paste or type all your character and scenario details here. Try to include:\n\nCharacter name: \nCharacter age: \nPhysical description: \nBackground: \nPersonality: \nRelationships: \n\nScenario title: \nLocation: \nTime: \nAtmosphere: \nInitial situation: \nOther characters: \nNarrative goals: \nTone and themes: \n\nThe AI will attempt to parse this information, even if it's not perfectly structured.`}\n        />\n\n        {processingError && (\n          <div className=\"processing-error\">\n            <p>{processingError}</p>\n          </div>\n        )}\n\n        <div className=\"setup-actions\">\n          <button \n            type=\"button\" \n            className=\"process-btn\" \n            onClick={processSetupText}\n            disabled={isProcessing || !setupText.trim()}\n          >\n            {isProcessing ? 'Processing...' : 'Process and Start Roleplay'}\n            {isProcessing && <RefreshCw size={18} className=\"spinning\" />}\n          </button>\n        </div>\n      </div>\n\n      <div className=\"quick-setup-help\">\n        <h3>Tips for best results:</h3>\n        <ul>\n          <li>Include clear labels like \"Character name:\" or \"Location:\" to help the AI identify information.</li>\n          <li>Provide as much detail as you can about both the character and scenario.</li>\n          <li>If you have specific roleplay instructions, label them clearly as \"Roleplay instructions:\"</li>\n          <li>The AI will make its best guess at extracting information, but you can always edit details in the chat.</li>\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport default QuickSetup;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}