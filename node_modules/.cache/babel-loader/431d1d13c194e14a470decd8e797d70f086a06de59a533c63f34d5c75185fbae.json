{"ast":null,"code":"/**\n * Utility functions for text formatting in the NarrativeForge app\n */\n\n/**\n * Ensures text has proper paragraph breaks\n * This function helps with the API responses that might lack proper spacing\n * \n * @param {string} text - The text to format\n * @returns {string} - Formatted text with proper paragraph breaks\n */\nexport const ensureParagraphBreaks = text => {\n  if (!text || typeof text !== 'string') return '';\n\n  // Normalize line endings\n  let formattedText = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n  // Convert single periods at the end of sentences followed by a space to period + double newline\n  formattedText = formattedText.replace(/\\.(?=\\s+[A-Z])/g, '.\\n\\n');\n\n  // Ensure two newlines between paragraphs\n  formattedText = formattedText.replace(/\\n{3,}/g, '\\n\\n');\n\n  // Convert blocks of text without breaks that are long into paragraphs\n  const paragraphs = formattedText.split(/\\n\\s*\\n/);\n  const improvedParagraphs = paragraphs.map(paragraph => {\n    // If paragraph is very long and has no internal breaks, split by sentences\n    if (paragraph.length > 300 && !paragraph.includes('\\n')) {\n      const sentences = paragraph.split(/(?<=\\. )/);\n\n      // Group sentences into more digestible paragraphs\n      let newParagraph = '';\n      let currentGroup = '';\n      sentences.forEach(sentence => {\n        if (currentGroup.length + sentence.length > 200) {\n          newParagraph += currentGroup + '\\n\\n';\n          currentGroup = sentence;\n        } else {\n          currentGroup += sentence;\n        }\n      });\n      if (currentGroup) {\n        newParagraph += currentGroup;\n      }\n      return newParagraph;\n    }\n    return paragraph;\n  });\n  return improvedParagraphs.join('\\n\\n');\n};\n\n/**\n * Preprocesses messages from AI to improve formatting\n * \n * @param {string} message - The message from AI to preprocess\n * @returns {string} - Formatted message with better spacing and line breaks\n */\nexport const preprocessAIMessage = message => {\n  if (!message || typeof message !== 'string') return '';\n\n  // Apply paragraph breaks\n  let processedMessage = ensureParagraphBreaks(message);\n\n  // Remove markdown bold formatting\n  processedMessage = processedMessage.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n\n  // Add spacing after social media handles and hashtags\n  processedMessage = processedMessage.replace(/@([a-zA-Z0-9_]+)/g, '@$1 ');\n  processedMessage = processedMessage.replace(/#([a-zA-Z0-9_]+)/g, '#$1 ');\n  return processedMessage;\n};\n\n/**\n * Apply special formatting for social media content\n * \n * @param {string} content - Social media content to format\n * @returns {string} - Formatted social media content with proper platform separation\n */\nexport const formatSocialMediaContent = content => {\n  if (!content || typeof content !== 'string') return '';\n\n  // Remove markdown bold formatting\n  let processedContent = content.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n\n  // Split content by paragraphs first to maintain overall structure\n  const paragraphs = processedContent.split(/\\n\\s*\\n/);\n\n  // Process each paragraph to identify platforms\n  let formattedParagraphs = [];\n  paragraphs.forEach(paragraph => {\n    // Check if this paragraph contains a platform indicator\n    const instagramMatch = paragraph.match(/Instagram|\\bIG\\b|\\binsta\\b/i);\n    const tiktokMatch = paragraph.match(/TikTok|\\btk\\b|\\btiktok\\b/i);\n    const youtubeMatch = paragraph.match(/YouTube|\\bYT\\b/i);\n    const twitterMatch = paragraph.match(/Twitter|tweet|\\bX\\b/i);\n    const snapchatMatch = paragraph.match(/Snapchat|\\bsnap\\b/i);\n    let platformName = null;\n    let platformEmoji = null;\n    if (instagramMatch) {\n      platformName = 'Instagram';\n      platformEmoji = 'üì±';\n    } else if (tiktokMatch) {\n      platformName = 'TikTok';\n      platformEmoji = 'üéµ';\n    } else if (youtubeMatch) {\n      platformName = 'YouTube';\n      platformEmoji = '‚ñ∂Ô∏è';\n    } else if (twitterMatch) {\n      platformName = 'Twitter';\n      platformEmoji = 'üê¶';\n    } else if (snapchatMatch) {\n      platformName = 'Snapchat';\n      platformEmoji = 'üëª';\n    }\n\n    // Format the paragraph\n    let formattedPara = paragraph.replace(/Instagram/g, 'üì± Instagram').replace(/TikTok/g, 'üéµ TikTok').replace(/YouTube/g, '‚ñ∂Ô∏è YouTube').replace(/Twitter/g, 'üê¶ Twitter').replace(/Snapchat/g, 'üëª Snapchat').replace(/(\\d+)k?\\s*followers/gi, '$1k followers üë•').replace(/(\\d+)k?\\s*likes/gi, '$1k likes ‚ù§Ô∏è').replace(/(\\d+)k?\\s*views/gi, '$1k views üëÅÔ∏è').replace(/(\\d+)k?\\s*shares/gi, '$1k shares üîÑ').replace(/(\\d+)k?\\s*comments/gi, '$1k comments üí¨').replace(/trending/gi, '<span class=\"highlight\">trending</span>');\n\n    // Add platform marker if one was detected\n    if (platformName) {\n      formattedPara = `[PLATFORM:${platformName}] ${platformEmoji} ${platformName}\\n${formattedPara}`;\n    }\n    formattedParagraphs.push(formattedPara);\n  });\n\n  // Join formatted paragraphs with sufficient spacing\n  return formattedParagraphs.join('\\n\\n\\n');\n};","map":{"version":3,"names":["ensureParagraphBreaks","text","formattedText","replace","paragraphs","split","improvedParagraphs","map","paragraph","length","includes","sentences","newParagraph","currentGroup","forEach","sentence","join","preprocessAIMessage","message","processedMessage","formatSocialMediaContent","content","processedContent","formattedParagraphs","instagramMatch","match","tiktokMatch","youtubeMatch","twitterMatch","snapchatMatch","platformName","platformEmoji","formattedPara","push"],"sources":["/Users/ryanmorrison/Code/narrativeforge/src/utils/textFormatUtils.js"],"sourcesContent":["/**\n * Utility functions for text formatting in the NarrativeForge app\n */\n\n/**\n * Ensures text has proper paragraph breaks\n * This function helps with the API responses that might lack proper spacing\n * \n * @param {string} text - The text to format\n * @returns {string} - Formatted text with proper paragraph breaks\n */\nexport const ensureParagraphBreaks = (text) => {\n  if (!text || typeof text !== 'string') return '';\n  \n  // Normalize line endings\n  let formattedText = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  \n  // Convert single periods at the end of sentences followed by a space to period + double newline\n  formattedText = formattedText.replace(/\\.(?=\\s+[A-Z])/g, '.\\n\\n');\n  \n  // Ensure two newlines between paragraphs\n  formattedText = formattedText.replace(/\\n{3,}/g, '\\n\\n');\n  \n  // Convert blocks of text without breaks that are long into paragraphs\n  const paragraphs = formattedText.split(/\\n\\s*\\n/);\n  \n  const improvedParagraphs = paragraphs.map(paragraph => {\n    // If paragraph is very long and has no internal breaks, split by sentences\n    if (paragraph.length > 300 && !paragraph.includes('\\n')) {\n      const sentences = paragraph.split(/(?<=\\. )/);\n      \n      // Group sentences into more digestible paragraphs\n      let newParagraph = '';\n      let currentGroup = '';\n      \n      sentences.forEach(sentence => {\n        if (currentGroup.length + sentence.length > 200) {\n          newParagraph += currentGroup + '\\n\\n';\n          currentGroup = sentence;\n        } else {\n          currentGroup += sentence;\n        }\n      });\n      \n      if (currentGroup) {\n        newParagraph += currentGroup;\n      }\n      \n      return newParagraph;\n    }\n    \n    return paragraph;\n  });\n  \n  return improvedParagraphs.join('\\n\\n');\n};\n\n/**\n * Preprocesses messages from AI to improve formatting\n * \n * @param {string} message - The message from AI to preprocess\n * @returns {string} - Formatted message with better spacing and line breaks\n */\nexport const preprocessAIMessage = (message) => {\n  if (!message || typeof message !== 'string') return '';\n  \n  // Apply paragraph breaks\n  let processedMessage = ensureParagraphBreaks(message);\n  \n  // Remove markdown bold formatting\n  processedMessage = processedMessage.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n  \n  // Add spacing after social media handles and hashtags\n  processedMessage = processedMessage.replace(/@([a-zA-Z0-9_]+)/g, '@$1 ');\n  processedMessage = processedMessage.replace(/#([a-zA-Z0-9_]+)/g, '#$1 ');\n  \n  return processedMessage;\n};\n\n/**\n * Apply special formatting for social media content\n * \n * @param {string} content - Social media content to format\n * @returns {string} - Formatted social media content with proper platform separation\n */\nexport const formatSocialMediaContent = (content) => {\n  if (!content || typeof content !== 'string') return '';\n  \n  // Remove markdown bold formatting\n  let processedContent = content.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n  \n  // Split content by paragraphs first to maintain overall structure\n  const paragraphs = processedContent.split(/\\n\\s*\\n/);\n  \n  // Process each paragraph to identify platforms\n  let formattedParagraphs = [];\n  \n  paragraphs.forEach(paragraph => {\n    // Check if this paragraph contains a platform indicator\n    const instagramMatch = paragraph.match(/Instagram|\\bIG\\b|\\binsta\\b/i);\n    const tiktokMatch = paragraph.match(/TikTok|\\btk\\b|\\btiktok\\b/i);\n    const youtubeMatch = paragraph.match(/YouTube|\\bYT\\b/i);\n    const twitterMatch = paragraph.match(/Twitter|tweet|\\bX\\b/i);\n    const snapchatMatch = paragraph.match(/Snapchat|\\bsnap\\b/i);\n    \n    let platformName = null;\n    let platformEmoji = null;\n    \n    if (instagramMatch) {\n      platformName = 'Instagram';\n      platformEmoji = 'üì±';\n    } else if (tiktokMatch) {\n      platformName = 'TikTok';\n      platformEmoji = 'üéµ';\n    } else if (youtubeMatch) {\n      platformName = 'YouTube';\n      platformEmoji = '‚ñ∂Ô∏è';\n    } else if (twitterMatch) {\n      platformName = 'Twitter';\n      platformEmoji = 'üê¶';\n    } else if (snapchatMatch) {\n      platformName = 'Snapchat';\n      platformEmoji = 'üëª';\n    }\n    \n    // Format the paragraph\n    let formattedPara = paragraph\n      .replace(/Instagram/g, 'üì± Instagram')\n      .replace(/TikTok/g, 'üéµ TikTok')\n      .replace(/YouTube/g, '‚ñ∂Ô∏è YouTube')\n      .replace(/Twitter/g, 'üê¶ Twitter')\n      .replace(/Snapchat/g, 'üëª Snapchat')\n      .replace(/(\\d+)k?\\s*followers/gi, '$1k followers üë•')\n      .replace(/(\\d+)k?\\s*likes/gi, '$1k likes ‚ù§Ô∏è')\n      .replace(/(\\d+)k?\\s*views/gi, '$1k views üëÅÔ∏è')\n      .replace(/(\\d+)k?\\s*shares/gi, '$1k shares üîÑ')\n      .replace(/(\\d+)k?\\s*comments/gi, '$1k comments üí¨')\n      .replace(/trending/gi, '<span class=\"highlight\">trending</span>');\n    \n    // Add platform marker if one was detected\n    if (platformName) {\n      formattedPara = `[PLATFORM:${platformName}] ${platformEmoji} ${platformName}\\n${formattedPara}`;\n    }\n    \n    formattedParagraphs.push(formattedPara);\n  });\n  \n  // Join formatted paragraphs with sufficient spacing\n  return formattedParagraphs.join('\\n\\n\\n');\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}