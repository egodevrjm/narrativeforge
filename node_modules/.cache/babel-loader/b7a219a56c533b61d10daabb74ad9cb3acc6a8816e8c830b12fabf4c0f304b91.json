{"ast":null,"code":"/**\n * Automatically detect message type based on content\n * \n * @param {string} text - The message text to analyze\n * @returns {string} - Detected message type: 'dialogue', 'action', 'thought', or 'social'\n */\nexport const detectMessageType = text => {\n  if (!text || typeof text !== 'string') return 'dialogue';\n  const lowerText = text.toLowerCase();\n\n  // Check for social media content first\n  if (lowerText.includes('@') || lowerText.includes('#') || lowerText.includes('instagram') || lowerText.includes('tiktok') || lowerText.includes('youtube') || lowerText.includes('twitter') || lowerText.includes('followers') || lowerText.includes('likes') || lowerText.includes('message requests:') || lowerText.includes('dm') || lowerText.includes('post') || lowerText.includes('comment') || lowerText.includes('notification')) {\n    return 'social';\n  }\n\n  // Check for action patterns\n  // Actions typically start with an \"I\" followed by a verb, or may be in third person style\n  if (text.match(/^I [a-z]+/) || text.match(/^\\*[^*]+\\*/) ||\n  // Text wrapped in asterisks like *walks away*\n  lowerText.startsWith('you ') || lowerText.includes(' walk') || lowerText.includes(' move') || lowerText.includes(' pick') || lowerText.includes(' grab') || lowerText.includes(' take') || lowerText.includes(' open') || lowerText.includes(' close') || lowerText.includes(' put') || lowerText.includes(' sit') || lowerText.includes(' stand') || lowerText.includes(' go to ')) {\n    return 'action';\n  }\n\n  // Check for thought patterns\n  if (text.match(/^I think/) || text.match(/^I wonder/) || text.match(/^I feel/) || text.match(/^I wish/) || text.match(/^I hope/) || text.match(/^I worry/) || text.match(/^I'm thinking/) || text.match(/^I'm wondering/) || text.match(/^Maybe/) || text.match(/^Hmm/) || text.match(/^\\([^)]+\\)/) ||\n  // Text in parentheses like (I wonder what's happening)\n  text.match(/^\\\"[^\"]+\\\"/) ||\n  // Text in quotes might be thoughts or dialogue\n  lowerText.includes('to myself')) {\n    return 'thought';\n  }\n\n  // Check if text is likely dialogue based on quotes or common speech patterns\n  if (text.includes('\"') || text.includes(\"'\") || text.includes('?') || text.includes('!') || lowerText.includes('said') || lowerText.includes('says') || lowerText.includes('asked') || lowerText.includes('tell') || lowerText.includes('hello') || lowerText.includes('hi ')) {\n    return 'dialogue';\n  }\n\n  // Default to dialogue for short messages\n  if (text.length < 60) {\n    return 'dialogue';\n  }\n\n  // For longer text without clear indicators, use a more sophisticated approach\n  // Count indicators for each type\n  let dialogueScore = 0;\n  let actionScore = 0;\n  let thoughtScore = 0;\n\n  // Dialogue indicators\n  dialogueScore += (text.match(/[?!]/g) || []).length * 2;\n  dialogueScore += (text.match(/\\b(say|tell|ask|speak|talk|respond|reply|answer)\\b/gi) || []).length * 2;\n\n  // Action indicators\n  actionScore += (text.match(/\\b(go|walk|move|turn|take|pick|grab|look|search|find|open|close|sit|stand)\\b/gi) || []).length * 2;\n\n  // Thought indicators\n  thoughtScore += (text.match(/\\b(think|wonder|consider|ponder|reflect|contemplate|feel|emotion|sense)\\b/gi) || []).length * 2;\n  thoughtScore += (text.match(/\\b(maybe|perhaps|possibly|I guess|I suppose)\\b/gi) || []).length * 3;\n\n  // Determine the highest score\n  if (thoughtScore > dialogueScore && thoughtScore > actionScore) {\n    return 'thought';\n  } else if (actionScore > dialogueScore) {\n    return 'action';\n  }\n\n  // Default to dialogue\n  return 'dialogue';\n};\n\n/**\n * Utility functions for text formatting in the NarrativeForge app\n */\n\n/**\n * Ensures text has proper paragraph breaks\n * This function helps with the API responses that might lack proper spacing\n * \n * @param {string} text - The text to format\n * @returns {string} - Formatted text with proper paragraph breaks\n */\nexport const ensureParagraphBreaks = text => {\n  if (!text || typeof text !== 'string') return '';\n\n  // Normalize line endings\n  let formattedText = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n  // Convert single periods at the end of sentences followed by a space to period + double newline\n  formattedText = formattedText.replace(/\\.(?=\\s+[A-Z])/g, '.\\n\\n');\n\n  // Ensure two newlines between paragraphs\n  formattedText = formattedText.replace(/\\n{3,}/g, '\\n\\n');\n\n  // Convert blocks of text without breaks that are long into paragraphs\n  const paragraphs = formattedText.split(/\\n\\s*\\n/);\n  const improvedParagraphs = paragraphs.map(paragraph => {\n    // If paragraph is very long and has no internal breaks, split by sentences\n    if (paragraph.length > 300 && !paragraph.includes('\\n')) {\n      const sentences = paragraph.split(/(?<=\\. )/);\n\n      // Group sentences into more digestible paragraphs\n      let newParagraph = '';\n      let currentGroup = '';\n      sentences.forEach(sentence => {\n        if (currentGroup.length + sentence.length > 200) {\n          newParagraph += currentGroup + '\\n\\n';\n          currentGroup = sentence;\n        } else {\n          currentGroup += sentence;\n        }\n      });\n      if (currentGroup) {\n        newParagraph += currentGroup;\n      }\n      return newParagraph;\n    }\n    return paragraph;\n  });\n  return improvedParagraphs.join('\\n\\n');\n};\n\n/**\n * Preprocesses messages from AI to improve formatting\n * \n * @param {string} message - The message from AI to preprocess\n * @returns {string} - Formatted message with better spacing and line breaks\n */\nexport const preprocessAIMessage = message => {\n  if (!message || typeof message !== 'string') return '';\n\n  // Apply paragraph breaks\n  let processedMessage = ensureParagraphBreaks(message);\n\n  // Remove markdown bold formatting\n  processedMessage = processedMessage.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n\n  // Add spacing after social media handles and hashtags\n  processedMessage = processedMessage.replace(/@([a-zA-Z0-9_]+)/g, '@$1 ');\n  processedMessage = processedMessage.replace(/#([a-zA-Z0-9_]+)/g, '#$1 ');\n  return processedMessage;\n};\n\n/**\n * Apply special formatting for social media content\n * \n * @param {string} content - Social media content to format\n * @returns {string} - Formatted social media content with proper platform separation\n */\nexport const formatSocialMediaContent = content => {\n  if (!content || typeof content !== 'string') return '';\n\n  // Remove markdown bold formatting\n  let formattedContent = content.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n\n  // Add explicit paragraph breaks before each platform mention\n  formattedContent = formattedContent.replace(/([^\\n])(üì±\\s*Instagram|üéµ\\s*TikTok|‚ñ∂Ô∏è\\s*YouTube|üê¶\\s*Twitter|üëª\\s*Snapchat)/g, '$1\\n\\n$2');\n\n  // Find and format platform mentions with emojis\n  formattedContent = formattedContent.replace(/Instagram/g, 'üì± Instagram').replace(/TikTok/g, 'üéµ TikTok').replace(/YouTube/g, '‚ñ∂Ô∏è YouTube').replace(/Twitter/g, 'üê¶ Twitter').replace(/Snapchat/g, 'üëª Snapchat').replace(/trending/gi, '<span class=\"highlight\">trending</span>').replace(/(\\d+)k?\\s*followers/gi, '$1k followers üë•').replace(/(\\d+)k?\\s*likes/gi, '$1k likes ‚ù§Ô∏è').replace(/(\\d+)k?\\s*views/gi, '$1k views üëÅÔ∏è').replace(/(\\d+)k?\\s*shares/gi, '$1k shares üîÑ').replace(/(\\d+)k?\\s*comments/gi, '$1k comments üí¨');\n\n  // Split content into paragraphs\n  let paragraphs = formattedContent.split(/\\n\\n+/);\n\n  // Mark each paragraph that starts with a platform indicator\n  let processedParagraphs = paragraphs.map(para => {\n    // Check if paragraph starts with a platform indicator\n    if (para.match(/^(üì±\\s*Instagram|üéµ\\s*TikTok|‚ñ∂Ô∏è\\s*YouTube|üê¶\\s*Twitter|üëª\\s*Snapchat)/)) {\n      // Extract platform name\n      const platformMatch = para.match(/^(üì±\\s*Instagram|üéµ\\s*TikTok|‚ñ∂Ô∏è\\s*YouTube|üê¶\\s*Twitter|üëª\\s*Snapchat)/);\n      let platformName = '';\n      if (platformMatch) {\n        if (platformMatch[0].includes('Instagram')) platformName = 'Instagram';else if (platformMatch[0].includes('TikTok')) platformName = 'TikTok';else if (platformMatch[0].includes('YouTube')) platformName = 'YouTube';else if (platformMatch[0].includes('Twitter')) platformName = 'Twitter';else if (platformMatch[0].includes('Snapchat')) platformName = 'Snapchat';\n      }\n\n      // Add platform marker\n      return `[PLATFORM:${platformName}] ${para}`;\n    }\n    return para;\n  });\n\n  // Add extra line breaks between platform sections for better visual separation\n  return processedParagraphs.join('\\n\\n\\n');\n};","map":{"version":3,"names":["detectMessageType","text","lowerText","toLowerCase","includes","match","startsWith","length","dialogueScore","actionScore","thoughtScore","ensureParagraphBreaks","formattedText","replace","paragraphs","split","improvedParagraphs","map","paragraph","sentences","newParagraph","currentGroup","forEach","sentence","join","preprocessAIMessage","message","processedMessage","formatSocialMediaContent","content","formattedContent","processedParagraphs","para","platformMatch","platformName"],"sources":["/Users/ryanmorrison/Code/narrativeforge/src/utils/textFormatUtils.js"],"sourcesContent":["/**\n * Automatically detect message type based on content\n * \n * @param {string} text - The message text to analyze\n * @returns {string} - Detected message type: 'dialogue', 'action', 'thought', or 'social'\n */\nexport const detectMessageType = (text) => {\n  if (!text || typeof text !== 'string') return 'dialogue';\n  \n  const lowerText = text.toLowerCase();\n  \n  // Check for social media content first\n  if (lowerText.includes('@') || lowerText.includes('#') || \n      lowerText.includes('instagram') || lowerText.includes('tiktok') || \n      lowerText.includes('youtube') || lowerText.includes('twitter') ||\n      lowerText.includes('followers') || lowerText.includes('likes') ||\n      lowerText.includes('message requests:') || lowerText.includes('dm') ||\n      lowerText.includes('post') || lowerText.includes('comment') ||\n      lowerText.includes('notification')) {\n    return 'social';\n  }\n  \n  // Check for action patterns\n  // Actions typically start with an \"I\" followed by a verb, or may be in third person style\n  if (text.match(/^I [a-z]+/) || \n      text.match(/^\\*[^*]+\\*/) || // Text wrapped in asterisks like *walks away*\n      lowerText.startsWith('you ') || \n      lowerText.includes(' walk') || lowerText.includes(' move') || \n      lowerText.includes(' pick') || lowerText.includes(' grab') || \n      lowerText.includes(' take') || lowerText.includes(' open') || \n      lowerText.includes(' close') || lowerText.includes(' put') ||\n      lowerText.includes(' sit') || lowerText.includes(' stand') ||\n      lowerText.includes(' go to ')) {\n    return 'action';\n  }\n  \n  // Check for thought patterns\n  if (text.match(/^I think/) || text.match(/^I wonder/) || \n      text.match(/^I feel/) || text.match(/^I wish/) ||\n      text.match(/^I hope/) || text.match(/^I worry/) ||\n      text.match(/^I'm thinking/) || text.match(/^I'm wondering/) ||\n      text.match(/^Maybe/) || text.match(/^Hmm/) ||\n      text.match(/^\\([^)]+\\)/) || // Text in parentheses like (I wonder what's happening)\n      text.match(/^\\\"[^\"]+\\\"/) || // Text in quotes might be thoughts or dialogue\n      lowerText.includes('to myself')) {\n    return 'thought';\n  }\n  \n  // Check if text is likely dialogue based on quotes or common speech patterns\n  if (text.includes('\"') || text.includes(\"'\") || \n      text.includes('?') || text.includes('!') ||\n      lowerText.includes('said') || lowerText.includes('says') ||\n      lowerText.includes('asked') || lowerText.includes('tell') ||\n      lowerText.includes('hello') || lowerText.includes('hi ')) {\n    return 'dialogue';\n  }\n  \n  // Default to dialogue for short messages\n  if (text.length < 60) {\n    return 'dialogue';\n  }\n  \n  // For longer text without clear indicators, use a more sophisticated approach\n  // Count indicators for each type\n  let dialogueScore = 0;\n  let actionScore = 0;\n  let thoughtScore = 0;\n  \n  // Dialogue indicators\n  dialogueScore += (text.match(/[?!]/g) || []).length * 2;\n  dialogueScore += (text.match(/\\b(say|tell|ask|speak|talk|respond|reply|answer)\\b/gi) || []).length * 2;\n  \n  // Action indicators\n  actionScore += (text.match(/\\b(go|walk|move|turn|take|pick|grab|look|search|find|open|close|sit|stand)\\b/gi) || []).length * 2;\n  \n  // Thought indicators\n  thoughtScore += (text.match(/\\b(think|wonder|consider|ponder|reflect|contemplate|feel|emotion|sense)\\b/gi) || []).length * 2;\n  thoughtScore += (text.match(/\\b(maybe|perhaps|possibly|I guess|I suppose)\\b/gi) || []).length * 3;\n  \n  // Determine the highest score\n  if (thoughtScore > dialogueScore && thoughtScore > actionScore) {\n    return 'thought';\n  } else if (actionScore > dialogueScore) {\n    return 'action';\n  }\n  \n  // Default to dialogue\n  return 'dialogue';\n};\n\n/**\n * Utility functions for text formatting in the NarrativeForge app\n */\n\n/**\n * Ensures text has proper paragraph breaks\n * This function helps with the API responses that might lack proper spacing\n * \n * @param {string} text - The text to format\n * @returns {string} - Formatted text with proper paragraph breaks\n */\nexport const ensureParagraphBreaks = (text) => {\n  if (!text || typeof text !== 'string') return '';\n  \n  // Normalize line endings\n  let formattedText = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  \n  // Convert single periods at the end of sentences followed by a space to period + double newline\n  formattedText = formattedText.replace(/\\.(?=\\s+[A-Z])/g, '.\\n\\n');\n  \n  // Ensure two newlines between paragraphs\n  formattedText = formattedText.replace(/\\n{3,}/g, '\\n\\n');\n  \n  // Convert blocks of text without breaks that are long into paragraphs\n  const paragraphs = formattedText.split(/\\n\\s*\\n/);\n  \n  const improvedParagraphs = paragraphs.map(paragraph => {\n    // If paragraph is very long and has no internal breaks, split by sentences\n    if (paragraph.length > 300 && !paragraph.includes('\\n')) {\n      const sentences = paragraph.split(/(?<=\\. )/);\n      \n      // Group sentences into more digestible paragraphs\n      let newParagraph = '';\n      let currentGroup = '';\n      \n      sentences.forEach(sentence => {\n        if (currentGroup.length + sentence.length > 200) {\n          newParagraph += currentGroup + '\\n\\n';\n          currentGroup = sentence;\n        } else {\n          currentGroup += sentence;\n        }\n      });\n      \n      if (currentGroup) {\n        newParagraph += currentGroup;\n      }\n      \n      return newParagraph;\n    }\n    \n    return paragraph;\n  });\n  \n  return improvedParagraphs.join('\\n\\n');\n};\n\n/**\n * Preprocesses messages from AI to improve formatting\n * \n * @param {string} message - The message from AI to preprocess\n * @returns {string} - Formatted message with better spacing and line breaks\n */\nexport const preprocessAIMessage = (message) => {\n  if (!message || typeof message !== 'string') return '';\n  \n  // Apply paragraph breaks\n  let processedMessage = ensureParagraphBreaks(message);\n  \n  // Remove markdown bold formatting\n  processedMessage = processedMessage.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n  \n  // Add spacing after social media handles and hashtags\n  processedMessage = processedMessage.replace(/@([a-zA-Z0-9_]+)/g, '@$1 ');\n  processedMessage = processedMessage.replace(/#([a-zA-Z0-9_]+)/g, '#$1 ');\n  \n  return processedMessage;\n};\n\n/**\n * Apply special formatting for social media content\n * \n * @param {string} content - Social media content to format\n * @returns {string} - Formatted social media content with proper platform separation\n */\nexport const formatSocialMediaContent = (content) => {\n  if (!content || typeof content !== 'string') return '';\n  \n  // Remove markdown bold formatting\n  let formattedContent = content.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n  \n  // Add explicit paragraph breaks before each platform mention\n  formattedContent = formattedContent\n    .replace(/([^\\n])(üì±\\s*Instagram|üéµ\\s*TikTok|‚ñ∂Ô∏è\\s*YouTube|üê¶\\s*Twitter|üëª\\s*Snapchat)/g, '$1\\n\\n$2');\n\n  // Find and format platform mentions with emojis\n  formattedContent = formattedContent\n    .replace(/Instagram/g, 'üì± Instagram')\n    .replace(/TikTok/g, 'üéµ TikTok')\n    .replace(/YouTube/g, '‚ñ∂Ô∏è YouTube')\n    .replace(/Twitter/g, 'üê¶ Twitter')\n    .replace(/Snapchat/g, 'üëª Snapchat')\n    .replace(/trending/gi, '<span class=\"highlight\">trending</span>')\n    .replace(/(\\d+)k?\\s*followers/gi, '$1k followers üë•')\n    .replace(/(\\d+)k?\\s*likes/gi, '$1k likes ‚ù§Ô∏è')\n    .replace(/(\\d+)k?\\s*views/gi, '$1k views üëÅÔ∏è')\n    .replace(/(\\d+)k?\\s*shares/gi, '$1k shares üîÑ')\n    .replace(/(\\d+)k?\\s*comments/gi, '$1k comments üí¨');\n\n  // Split content into paragraphs\n  let paragraphs = formattedContent.split(/\\n\\n+/);\n  \n  // Mark each paragraph that starts with a platform indicator\n  let processedParagraphs = paragraphs.map(para => {\n    // Check if paragraph starts with a platform indicator\n    if (para.match(/^(üì±\\s*Instagram|üéµ\\s*TikTok|‚ñ∂Ô∏è\\s*YouTube|üê¶\\s*Twitter|üëª\\s*Snapchat)/)) {\n      // Extract platform name\n      const platformMatch = para.match(/^(üì±\\s*Instagram|üéµ\\s*TikTok|‚ñ∂Ô∏è\\s*YouTube|üê¶\\s*Twitter|üëª\\s*Snapchat)/);\n      let platformName = '';\n      \n      if (platformMatch) {\n        if (platformMatch[0].includes('Instagram')) platformName = 'Instagram';\n        else if (platformMatch[0].includes('TikTok')) platformName = 'TikTok';\n        else if (platformMatch[0].includes('YouTube')) platformName = 'YouTube';\n        else if (platformMatch[0].includes('Twitter')) platformName = 'Twitter';\n        else if (platformMatch[0].includes('Snapchat')) platformName = 'Snapchat';\n      }\n      \n      // Add platform marker\n      return `[PLATFORM:${platformName}] ${para}`;\n    }\n    return para;\n  });\n  \n  // Add extra line breaks between platform sections for better visual separation\n  return processedParagraphs.join('\\n\\n\\n');\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}